import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import pandas as pd
from sklearn.preprocessing import StandardScaler


class GradientMethodsAnalysis:
    def __init__(self):
        self.students_data = None
        self.generate_student_data()
        self.setup_style()

    def setup_style(self):
        """Налаштування стилю графіків"""
        plt.rcParams['font.family'] = 'DejaVu Sans'
        plt.rcParams['axes.unicode_minus'] = False
        sns.set_palette("viridis")

    def generate_student_data(self):
        """Генерація синтетичних даних студентів"""
        np.random.seed(42)
        n_students = 100

        self.students_data = pd.DataFrame({
            'study_hours': np.random.normal(15, 5, n_students),
            'attendance_rate': np.random.normal(85, 10, n_students),
            'add_courses': np.random.normal(12, 5, n_students),
            'satisfaction': np.random.normal(7, 2, n_students)
        })

        # Генерація підсумкового балу
        self.students_data['exam_score'] = (
                0.4 * self.students_data['study_hours'] +
                0.3 * self.students_data['attendance_rate'] +
                0.2 * self.students_data['add_courses'] +
                0.1 * self.students_data['satisfaction'] +
                np.random.normal(0, 5, n_students)
        )

        print("Згенеровано дані 100 студентів")
        print("Основні статистики:")
        print(self.students_data.describe())

    def visualize_student_data(self):
        """Візуалізація даних студентів"""
        fig, axes = plt.subplots(2, 3, figsize=(15, 10))
        fig.suptitle('Аналіз даних студентів Університету', fontsize=16, fontweight='bold')

        # 1. Години навчання vs Бал іспиту
        axes[0, 0].scatter(self.students_data['study_hours'], self.students_data['exam_score'], alpha=0.6)
        axes[0, 0].set_xlabel('Години навчання/тиждень')
        axes[0, 0].set_ylabel('Бал іспиту')
        axes[0, 0].set_title('Вплив годин навчання на успішність')
        axes[0, 0].grid(True, alpha=0.3)

        # 2. Відвідуваність vs Бал іспиту
        axes[0, 1].scatter(self.students_data['attendance_rate'], self.students_data['exam_score'], alpha=0.6,
                           color='green')
        axes[0, 1].set_xlabel('Відвідуваність (%)')
        axes[0, 1].set_ylabel('Бал іспиту')
        axes[0, 1].set_title('Вплив відвідуваності на успішність')
        axes[0, 1].grid(True, alpha=0.3)

        # 3. Додаткові курси vs Бал іспиту
        axes[0, 2].scatter(self.students_data['add_courses'], self.students_data['exam_score'], alpha=0.6, color='red')
        axes[0, 2].set_xlabel('Бали за додаткові курси')
        axes[0, 2].set_ylabel('Бал іспиту')
        axes[0, 2].set_title('Вплив додаткових курсів на успішність')
        axes[0, 2].grid(True, alpha=0.3)

        # 4. Задоволеність vs Бал іспиту
        axes[1, 0].scatter(self.students_data['satisfaction'], self.students_data['exam_score'], alpha=0.6,
                           color='orange')
        axes[1, 0].set_xlabel('Рівень задоволеності')
        axes[1, 0].set_ylabel('Бал іспиту')
        axes[1, 0].set_title('Вплив задоволеності на успішність')
        axes[1, 0].grid(True, alpha=0.3)

        # 5. Кореляційна матриця
        corr_matrix = self.students_data.corr()
        im = axes[1, 1].imshow(corr_matrix.values, cmap='coolwarm', aspect='auto')
        axes[1, 1].set_xticks(range(len(corr_matrix.columns)))
        axes[1, 1].set_yticks(range(len(corr_matrix.columns)))
        axes[1, 1].set_xticklabels(corr_matrix.columns, rotation=45)
        axes[1, 1].set_yticklabels(corr_matrix.columns)
        axes[1, 1].set_title('Матриця кореляцій')

        # Додавання значень кореляції
        for i in range(len(corr_matrix.columns)):
            for j in range(len(corr_matrix.columns)):
                axes[1, 1].text(j, i, f'{corr_matrix.iloc[i, j]:.2f}',
                                ha='center', va='center', fontsize=8)

        # 6. Розподіл балів іспиту
        axes[1, 2].hist(self.students_data['exam_score'], bins=15, alpha=0.7, color='purple')
        axes[1, 2].set_xlabel('Бал іспиту')
        axes[1, 2].set_ylabel('Кількість студентів')
        axes[1, 2].set_title('Розподіл балів іспиту')
        axes[1, 2].grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

    def objective_function(self, params, X, y):
        """Цільова функція - мінімізація MSE"""
        predictions = X @ params
        return np.mean((predictions - y) ** 2)

    def gradient(self, params, X, y):
        """Градієнт цільової функції"""
        predictions = X @ params
        return (2 / len(y)) * X.T @ (predictions - y)

    def compare_conjugate_gradient_methods(self):
        """Порівняння алгоритмів спряжених градієнтів"""
        print("\n" + "=" * 60)
        print("ПОРІВНЯННЯ АЛГОРИТМІВ СПРЯЖЕНИХ ГРАДІЄНТІВ")
        print("=" * 60)

        X = self.students_data[['study_hours', 'attendance_rate', 'add_courses', 'satisfaction']].values
        y = self.students_data['exam_score'].values

        # Додаємо стовпець для intercept
        X = np.column_stack([np.ones(len(X)), X])

        initial_params = np.zeros(X.shape[1])

        methods = ['CG', 'BFGS', 'L-BFGS-B']
        results = {}

        fig, axes = plt.subplots(1, 2, figsize=(15, 6))
        fig.suptitle('Порівняння алгоритмів спряжених градієнтів', fontsize=14, fontweight='bold')

        colors = ['#2E86AB', '#A23B72', '#F18F01']

        for i, method in enumerate(methods):
            # Трасування збіжності
            history = []

            def callback(xk):
                history.append(self.objective_function(xk, X, y))

            result = minimize(self.objective_function, initial_params,
                              args=(X, y), method=method, jac=self.gradient,
                              callback=callback, options={'disp': False})

            results[method] = {
                'params': result.x,
                'fun': result.fun,
                'nfev': result.nfev,
                'nit': result.nit,
                'success': result.success,
                'history': history
            }

            print(f"\nМетод: {method}")
            print(f"Функція втрат: {result.fun:.4f}")
            print(f"Кількість ітерацій: {result.nit}")
            print(f"Кількість обчислень функції: {result.nfev}")
            print(f"Успішність: {'Так' if result.success else 'Ні'}")

            # Графік збіжності
            axes[0].plot(history, label=method, color=colors[i], linewidth=2)

        axes[0].set_xlabel('Ітерація')
        axes[0].set_ylabel('Функція втрат')
        axes[0].set_title('Збіжність методів')
        axes[0].legend()
        axes[0].grid(True, alpha=0.3)

        # Порівняння швидкості збіжності
        method_names = list(results.keys())
        iterations = [results[method]['nit'] for method in method_names]

        bars = axes[1].bar(method_names, iterations, color=colors[:len(method_names)])
        axes[1].set_xlabel('Метод')
        axes[1].set_ylabel('Кількість ітерацій')
        axes[1].set_title('Швидкість збіжності')

        # Додавання значень на стовпцях
        for bar, value in zip(bars, iterations):
            axes[1].text(bar.get_x() + bar.get_width() / 2, bar.get_height() + 0.1,
                         f'{value}', ha='center', va='bottom')

        plt.tight_layout()
        plt.show()

        return results


# Запуск аналізу
if __name__ == "__main__":
    print("МОНІТОРИНГ НАВЧАЛЬНИХ ДОСЯГНЕНЬ СТУДЕНТІВ")
    print("АНАЛІЗ ГРАДІЄНТНИМИ МЕТОДАМИ")

    analysis = GradientMethodsAnalysis()
    analysis.visualize_student_data()
    results = analysis.compare_conjugate_gradient_methods()

print("\n" + "=" * 70)
print("АНАЛІЗ УСПІШНОСТІ ЗАВЕРШЕНО!")
print("=" * 70)

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import networkx as nx
from matplotlib.patches import FancyBboxPatch


class AntColonyOptimization:
    def __init__(self):
        self.students_data = None
        self.course_network = None
        self.generate_student_data()
        self.create_course_network()
        self.setup_style()

    def setup_style(self):
        """Налаштування стилю графіків"""
        plt.rcParams['font.family'] = 'DejaVu Sans'

    def generate_student_data(self):
        """Генерація даних студентів"""
        np.random.seed(42)
        n_students = 50

        self.students_data = pd.DataFrame({
            'student_id': range(n_students),
            'study_hours': np.random.normal(15, 5, n_students),
            'attendance_rate': np.random.normal(85, 10, n_students),
            'add_courses': np.random.normal(12, 5, n_students),
            'satisfaction': np.random.normal(7, 2, n_students)
        })

        self.students_data['exam_score'] = (
                0.4 * self.students_data['study_hours'] +
                0.3 * self.students_data['attendance_rate'] +
                0.2 * self.students_data['add_courses'] +
                0.1 * self.students_data['satisfaction'] +
                np.random.normal(0, 5, n_students)
        )

    def create_course_network(self):
        """Створення мережі курсів для оптимізації"""
        self.course_network = nx.Graph()

        courses = ['Математика', 'Фізика', 'Програмування', 'Англійська',
                   'Статистика', 'Дискретна математика', 'Бази даних', 'ML']

        # Додавання вузлів (курсів)
        for i, course in enumerate(courses):
            self.course_network.add_node(course, students=np.random.randint(20, 100))

        # Додавання ребер (зв'язків між курсами)
        for i in range(len(courses)):
            for j in range(i + 1, len(courses)):
                if np.random.random() > 0.4:  # 60% ймовірність зв'язку
                    weight = np.random.randint(1, 10)
                    self.course_network.add_edge(courses[i], courses[j], weight=weight)

    def ant_colony_optimization(self, n_ants=10, n_iterations=50, alpha=1.0, beta=2.0, rho=0.5):
        """Реалізація алгоритму мурашиних колоній"""
        nodes = list(self.course_network.nodes())
        n_nodes = len(nodes)

        # Ініціалізація феромонів
        pheromone = np.ones((n_nodes, n_nodes))

        best_path = None
        best_score = float('inf')
        convergence_history = []

        for iteration in range(n_iterations):
            ant_paths = []
            ant_scores = []

            for ant in range(n_ants):
                # Випадковий початковий вузол
                current_node = np.random.randint(n_nodes)
                visited = [current_node]
                path_length = 0

                while len(visited) < n_nodes:
                    # Обчислення ймовірностей переходу
                    probabilities = []
                    unvisited = [i for i in range(n_nodes) if i not in visited]

                    for next_node in unvisited:
                        if self.course_network.has_edge(nodes[current_node], nodes[next_node]):
                            tau = pheromone[current_node, next_node] ** alpha
                            eta = (1.0 / self.course_network[nodes[current_node]][nodes[next_node]]['weight']) ** beta
                            probabilities.append(tau * eta)
                        else:
                            probabilities.append(0)

                    # Нормалізація ймовірностей
                    if sum(probabilities) > 0:
                        probabilities = [p / sum(probabilities) for p in probabilities]
                        next_index = np.random.choice(unvisited, p=probabilities)
                    else:
                        next_index = np.random.choice(unvisited)

                    # Оновлення шляху
                    if self.course_network.has_edge(nodes[current_node], nodes[next_index]):
                        path_length += self.course_network[nodes[current_node]][nodes[next_index]]['weight']

                    visited.append(next_index)
                    current_node = next_index

                ant_paths.append(visited)
                ant_scores.append(path_length)

                # Оновлення найкращого шляху
                if path_length < best_score:
                    best_score = path_length
                    best_path = visited

            # Оновлення феромонів
            pheromone *= (1 - rho)  # Випаровування

            # Додавання нового феромону
            for path, score in zip(ant_paths, ant_scores):
                for i in range(len(path) - 1):
                    pheromone[path[i], path[i + 1]] += 1.0 / score
                    pheromone[path[i + 1], path[i]] += 1.0 / score

            convergence_history.append(best_score)

        return best_path, best_score, convergence_history, nodes

    def visualize_ant_colony(self):
        """Візуалізація роботи алгоритму мурашиних колоній"""
        print("\n" + "=" * 60)
        print("АЛГОРИТМ МУРАШИНИХ КОЛОНІЙ ДЛЯ ОПТИМІЗАЦІЇ КУРСІВ")
        print("=" * 60)

        fig = plt.figure(figsize=(20, 12))

        # 1. Мережа курсів
        ax1 = plt.subplot2grid((2, 3), (0, 0), colspan=2)
        ax1.set_title('Мережа курсів університету', fontsize=14, fontweight='bold', pad=20)

        pos = nx.spring_layout(self.course_network, seed=42)

        # Визначення розмірів вузлів за кількістю студентів
        node_sizes = [self.course_network.nodes[node]['students'] * 10 for node in self.course_network.nodes()]

        # Кольори за ступенем вузла
        degrees = dict(self.course_network.degree())
        node_colors = [degrees[node] for node in self.course_network.nodes()]

        # Малювання мережі
        nx.draw_networkx_nodes(self.course_network, pos, node_size=node_sizes,
                               node_color=node_colors, cmap='viridis', alpha=0.8, ax=ax1)
        nx.draw_networkx_edges(self.course_network, pos, alpha=0.5, edge_color='gray', ax=ax1)
        nx.draw_networkx_labels(self.course_network, pos, font_size=8, ax=ax1)

        # Додавання ваг ребер
        edge_labels = nx.get_edge_attributes(self.course_network, 'weight')
        nx.draw_networkx_edge_labels(self.course_network, pos, edge_labels=edge_labels, font_size=6, ax=ax1)

        ax1.axis('off')

        # 2. Запуск алгоритму
        ax2 = plt.subplot2grid((2, 3), (0, 2))
        best_path, best_score, convergence, nodes = self.ant_colony_optimization()

        ax2.plot(convergence, linewidth=2, color='red')
        ax2.set_xlabel('Ітерація')
        ax2.set_ylabel('Довжина найкращого шляху')
        ax2.set_title('Збіжність алгоритму', fontweight='bold')
        ax2.grid(True, alpha=0.3)

        # 3. Найкращий маршрут
        ax3 = plt.subplot2grid((2, 3), (1, 0), colspan=3)
        ax3.set_title('Найкращий маршрут мурашиного алгоритму', fontsize=14, fontweight='bold', pad=20)

        # Малювання найкращого шляху
        node_list = [nodes[i] for i in best_path]
        path_edges = [(node_list[i], node_list[i + 1]) for i in range(len(node_list) - 1)]

        nx.draw_networkx_nodes(self.course_network, pos, node_size=300,
                               node_color='lightblue', alpha=0.9, ax=ax3)
        nx.draw_networkx_edges(self.course_network, pos, edgelist=path_edges,
                               edge_color='red', width=3, alpha=0.7, ax=ax3)
        nx.draw_networkx_labels(self.course_network, pos, font_size=9, ax=ax3)

        # Додавання стрілок для напрямку
        for i, (u, v) in enumerate(path_edges):
            x1, y1 = pos[u]
            x2, y2 = pos[v]
            ax3.annotate("", xy=(x2, y2), xytext=(x1, y1),
                         arrowprops=dict(arrowstyle="->", color="red", lw=2,
                                         connectionstyle="arc3,rad=0.1"))

        ax3.axis('off')

        # Інформація про результат
        ax2.text(0.02, 0.98, f'Найкраща довжина: {best_score:.2f}\n'
                             f'Кількість курсів: {len(best_path)}',
                 transform=ax2.transAxes, verticalalignment='top',
                 bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))

        # 4. Порівняння з іншими методами
        plt.figtext(0.02, 0.02,
                    "ПЕРЕВАГИ АЛГОРИТМУ МУРАШИНИХ КОЛОНІЙ:\n"
                    "+ Ефективний для комбінаторних задач\n"
                    "+ Знаходить близькі до оптимальних розв'язки\n"
                    "+ Стійкий до локальних оптимумів\n"
                    "+ Паралельний пошук декількома 'мурахами'\n\n"
                    "ПОРІВНЯННЯ З ІНШИМИ МЕТОДАМИ:\n"
                    "- Градієнтні методи: не працюють з дискретними задачами\n"
                    "- Генетичні алгоритми: повільніша збіжність\n"
                    "- Жадібні алгоритми: можуть застрявати в локальних оптимумах",
                    fontsize=10, bbox=dict(boxstyle='round', facecolor='lightcyan', alpha=0.8))

        plt.tight_layout()
        plt.show()

        print(f"\nРЕЗУЛЬТАТ АЛГОРИТМУ:")
        print(f"Найкращий шлях: {' > '.join([nodes[i] for i in best_path])}")
        print(f"Довжина шляху: {best_score:.2f}")
        print(f"Кількість курсів у маршруті: {len(best_path)}")


# Запуск аналізу
if __name__ == "__main__":
    print("МОНІТОРИНГ НАВЧАЛЬНИХ ДОСЯГНЕНЬ СТУДЕНТІВ")
    print("АНАЛІЗ МЕТОДОМ МУРАШИНИХ КОЛОНІЙ")

    aco = AntColonyOptimization()
    aco.visualize_ant_colony()
